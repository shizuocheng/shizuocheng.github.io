{"meta":{"title":"漫步Dog","subtitle":"Shi zuocheng's personal blog","description":null,"author":"Shi Zuocheng","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"一个很好理解01背包原理的故事","slug":"背包诠释","date":"2019-09-29T15:26:45.000Z","updated":"2019-09-29T14:49:54.334Z","comments":true,"path":"2019/09/29/背包诠释/","link":"","permalink":"http://yoursite.com/2019/09/29/背包诠释/","excerpt":"通过一个国王挖矿的故事，换个角度理解01背包问题&emsp;&emsp;因为过几天要讲到贪心和背包问题了，今天晚上温习了一下好久没看的背包问题。 第一节—-初识动态规划经典的01背包问题是这样的： 有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取] 为了用一种生动又更形象的方式来讲解此题，我把此题用另一种方式来描述，如下： 有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。","text":"通过一个国王挖矿的故事，换个角度理解01背包问题&emsp;&emsp;因为过几天要讲到贪心和背包问题了，今天晚上温习了一下好久没看的背包问题。 第一节—-初识动态规划经典的01背包问题是这样的： 有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取] 为了用一种生动又更形象的方式来讲解此题，我把此题用另一种方式来描述，如下： 有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。 题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为p[i]。 题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有p[i]人去挖的话，就一定能恰好挖出g[i]个金子。否则一个金子都挖不出来。 题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。 题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。 题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。 题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。 题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。 那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？ 国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？” 得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？” “当然，当然”大臣们回答倒。 国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？” 国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得x + 8888个金子，对吗？” “是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。 国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？” 国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？” 国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “请您放心，这个问题难不倒我”。左部下向国王打包票说到。 国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “当然能了！交给我吧！”右部下同左部下一样自信地回答道。 “那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。 故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。 国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。 因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！” 因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。 当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？ 那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！ 没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？ 很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！ 故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。 子问题： 国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。 思考动态规划的第一点—-最优子结构： 国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。 思考动态规划的第二点—-子问题重叠： 实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。 思考动态规划的第三点—-边界： 想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。 思考动态规划的第四点—-子问题独立： 要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。 这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。 有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用g[i]表示第i个金矿能够挖出的金子数，用p[i]表示挖第i个金矿需要的人数，用函数f(p,i)表示当有p个人和编号为0、1、2、3、……、i的金矿时能够得到的最大金子数的话，f(p,i)等于什么呢？或者说f(p,i)的转移方程是怎样的呢？ 答案是： 当i = 0且p&gt;= p[i]时f(p,i) = g[i] 当i = 0且p&lt;p[i]时f(p,i) = 0 当i != 0时f(p,i) = f(p-p[i], i-1) +g[i]与f(p, i-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”请读者弄明白后再继续往下看。 第二节—-动态规划的优点现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事： 国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？ 但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。 国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？” “国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。 “嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。 国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……” 不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。” 国王高兴的问到：“此话如何讲？” “打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。” 国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？” “因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 * 10等于100000个不同的问题。”小才一边算着一边回答。 “什么？十万个问题？十万个人力？”国王有点失望。 “请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。”小才立刻回答到。 故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。 思考动态规划的第五点—-做备忘录： 正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。 思考动态规划的第六点—-时间分析： 正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。 而如果用动态规划，最多大概只有1000*100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。 非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount * chooseCount个常数。在金矿模型中，子问题最多有大概p * n个(其中p是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = p * n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为T = O(questionCount * chooseCount) =O(p * n)，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。 这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！ 第三节—-动态规划的思考角度那么什么是动态规划呢？我个人觉得，如果一个解决问题的方法满足上面六个思考点中的前四个，那么这个方法就属于动态规划。而在思考动态规划方法时，后两点同样也是需要考虑的。 面对问题要寻找动态规划的方法，首先要清楚一点，动态规划不是算法，它是一种方法，它是在一件事情发生的过程中寻找最优值的方法，因此，我们需要对这件事情所发生的过程进行考虑。而通常我们从过程的最后一步开始考虑，而不是先考虑过程的开始。 打个比方，上面的挖金矿问题，我们可以认为整个开采过程是从西至东进行开采的（也就是从第0座开始），那么总有面对最后一座金矿的时候（第9座），对这座金矿不外乎两个选择，开采与不开采，在最后一步确定时再去确定倒数第二步，直到考虑第0座金矿（过程的开始）。 而过程的开始，也就是考虑的最后一步，就是边界。 因此在遇到一个问题想用动态规划的方法去解决时，不妨先思考一下这个过程是怎样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程，比如后面的练习。 第四节—-总结那么遇到问题如何用动态规划去解决呢？根据上面的分析我们可以按照下面的步骤去考虑： 1、构造问题所对应的过程。 2、思考过程的最后一个步骤，看看有哪些选择情况。 3、找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 4、使得子问题符合“最优子结构”。 5、找到边界，考虑边界的各种处理方式。 6、确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 7、考虑如何做备忘录。 8、分析所需时间是否满足要求。 9、写出转移方程式。","categories":[],"tags":[]},{"title":"你必须非常努力，才能看起来毫不费力","slug":"你必须很努力","date":"2019-09-29T14:26:45.000Z","updated":"2019-09-29T14:50:15.612Z","comments":true,"path":"2019/09/29/你必须很努力/","link":"","permalink":"http://yoursite.com/2019/09/29/你必须很努力/","excerpt":"你必须非常努力，才能看起来毫不费力有一群人，他们积极自律，每天按计划行事，有条不紊；他们不张扬，把自己当成最卑微的小草，等待着人生开出花朵的那天。他们早晨5点多起来健身，你在睡觉；7点开始享受丰盛的早餐，蛋白质维生素淀粉粗纤维样样俱全，为新的一天起了一个好头，当他们收拾妥当准备开始一整天的工作时，你还在睡觉； 他们用上午的高效时间完成了一个又一个任务，甚至发现的新的商机，发现了有可能给人生带来改观的机遇，当午餐时间临近，他们伸了伸腰，准备稍作休息，此时你终于起床。 他们的午餐不铺张浪费，却营养全面，他们有选择的进食，因为清楚的知道自己想要的是什么，而你也在起床之后但觉到了饿意，你早早的洗了把脸，甚至连牙都没刷，打开冰箱，拿出了昨晚跟朋友high过之后带回来的薯条以及可乐；","text":"你必须非常努力，才能看起来毫不费力有一群人，他们积极自律，每天按计划行事，有条不紊；他们不张扬，把自己当成最卑微的小草，等待着人生开出花朵的那天。他们早晨5点多起来健身，你在睡觉；7点开始享受丰盛的早餐，蛋白质维生素淀粉粗纤维样样俱全，为新的一天起了一个好头，当他们收拾妥当准备开始一整天的工作时，你还在睡觉； 他们用上午的高效时间完成了一个又一个任务，甚至发现的新的商机，发现了有可能给人生带来改观的机遇，当午餐时间临近，他们伸了伸腰，准备稍作休息，此时你终于起床。 他们的午餐不铺张浪费，却营养全面，他们有选择的进食，因为清楚的知道自己想要的是什么，而你也在起床之后但觉到了饿意，你早早的洗了把脸，甚至连牙都没刷，打开冰箱，拿出了昨晚跟朋友high过之后带回来的薯条以及可乐； 午睡之后，他们重新积极的投入工作，而你也终于吃饱喝足，坐在了电脑前。是的，你的一天开始了。 晚上回到家里，他们也打开了电脑，也许是为了完成白天没来得及做完的工作，也许是因为前两天刚报了一个网络课堂，此时你还沉浸在dota中，你发的贴子还不够有人气，你发现空老师又更新微薄了，电视剧里男女猪脚还没有最后在一起，作恶多端的女二号还没有得到应有的报应。 终于，22点到了，他们停下了工作，或许去满满的书架上拿下了一本书，或许拿起了自己心爱的乐器打算练练手，或许已经上床睡觉。当然，睡之前他们会想一想，自己在这一天都做了什么，有什么收获，又有什么教训。 最后，他们又重新提醒了一下自己那个埋在内心深处的梦想，然后满意的睡去了。此时的你还在等待升级，还在顶贴子，还在刷微薄，还在为了男一号女一号哭哭啼啼，你的一天才刚刚开始精彩。 后半夜，你隐约感到了困意，依依不舍的关掉了电脑，身上已经很臭，你却懒得去洗一个澡。你走向了乱糟糟的床，钻进了肮脏的被窝，掏出了手机——是的，爪机党伤不起。 你隐约知道自己的身边有那么一群“他们”，可是你却没有办法实实在在的感受到他们的存在。直到有一天，你和“他/她”终于浪漫的相见了—— 他/她是老总，你是普通的打工仔；他/她是主任，你是弱爆了的小职员；他/她游历各国，念着你想念的大学，拍着你想拍的照片，过着你想过的生活，他/她各种恣意的小清新， 而你，是的，我知道你恨小清新，可是这又有什么关系？事实已经如此，你就是那个电脑荧光照射下的SB。","categories":[],"tags":[]},{"title":"PHP实现将网页输入信息存入Mysql数据库","slug":"纳新网站的实现","date":"2019-09-28T14:26:45.000Z","updated":"2019-09-28T15:52:53.442Z","comments":true,"path":"2019/09/28/纳新网站的实现/","link":"","permalink":"http://yoursite.com/2019/09/28/纳新网站的实现/","excerpt":"HTML网页实现用户输入&emsp;&emsp;具体网页框架和美化元素这里不一一描述，直接写主题内容。 一、假设有一个报名网站，需要用户输入学号姓名和个人简介，具体body中的input代码如下： 123&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; // 输入姓名&lt;input type=&quot;text&quot; id=&quot;num&quot; /&gt; // 输入学号&lt;input type=&quot;text&quot; id=&quot;intro&quot; /&gt; // 输入个人简介 二、 在用户输入之后肯定会设置一个提交按钮，在input上放入onclick事件属性，具体实现如下： 1&lt;input type=&quot;submit&quot; id=&quot;sub&quot; onclick=&quot;sub();&quot; /&gt; //设置sub()点击事件","text":"HTML网页实现用户输入&emsp;&emsp;具体网页框架和美化元素这里不一一描述，直接写主题内容。 一、假设有一个报名网站，需要用户输入学号姓名和个人简介，具体body中的input代码如下： 123&lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; // 输入姓名&lt;input type=&quot;text&quot; id=&quot;num&quot; /&gt; // 输入学号&lt;input type=&quot;text&quot; id=&quot;intro&quot; /&gt; // 输入个人简介 二、 在用户输入之后肯定会设置一个提交按钮，在input上放入onclick事件属性，具体实现如下： 1&lt;input type=&quot;submit&quot; id=&quot;sub&quot; onclick=&quot;sub();&quot; /&gt; //设置sub()点击事件 三、 定义sub()函数体 &emsp;（一）、 将输入的name、num、intro获取 123456var name = document.getElementById(&quot;name&quot;);var num = document.getElementById(&quot;num&quot;)var intro = document.getElementById(&quot;intro&quot;)// 这里有必要说一下，input中若使用的是id属性要用getElementById来获取输入信息；input若是用name属性获取则需要用document.getElementsByName来获取。// 一定要搞清楚，当时我就在这里踩了坑，此篇blog统一使用ById，以后会有专门的blog介绍ByName和ById的区别。 &emsp; （二）、 处理输入信息为空的情况 &emsp;&emsp;因为大背景是一个报名网站，所以输入的姓名学号不能为空，若为空要对用户进行提示让其重新输入。实现代码如下： 123456789// 代码很好理解，不作敖述if (name.value == &quot;&quot; || name.value == undefined) &#123; mui.alert(&quot;姓名没有填写&quot;, &quot;抱歉&quot;, &quot;返回重填&quot;) return;&#125;if (num.value == &quot;&quot; || num.value == undefined) &#123; mui.alert(&quot;学号没有填写&quot;, &quot;抱歉&quot;, &quot;返回重填&quot;) return;&#125; &emsp;（三）、 给baoming.php文件发送输入信息 &emsp;&emsp;此部分是html和php交互的核心部分 1234567891011 // 在http.post中第一个&#123;&#125;中写入baoming.php的url和发送的data信息，第二个是一个匿名函数 http.post(&#123; url: &quot;api/baoming.php&quot;, data: &quot;name=&quot; + name.value + &quot;&amp;num=&quot; + num.value + &quot;&amp;intro=&quot; + intro.value &#125;, function (err, result) &#123; //baoming.php中会对结果进行处理，通过返回的result的值提示用户具体信息。 if (result == &quot;0&quot;) &#123; alert(&quot;报名成功&quot;) &#125; else if (result == &quot;1&quot;) &#123; alert(&quot;已报名&quot;) &#125; else &#123; mui.alert(&quot;报名失败&quot;); &#125;&#125;) &emsp;（四）、 关于mui.js文件和tool.js文件 &emsp;&emsp;mui.js和tool.js是公共代码库文件，会用即可。 &emsp;&emsp;在body开头放入一段代码引入miu.js、完成mui.init函数，代码如下： 123&lt;script src=&quot;js/mui.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; mui.init() &lt;/script&gt; &lt;script src=&quot;js/tool.js&quot;&gt;&lt;/script&gt; connect.php文件的实现&emsp;&emsp;connect.php主要完成对数据库的连接 一、首先定义一个mysql_conf数组存放服务器的地址，用户名和密码，代码如下： 123456$mysql_conf = array( &apos;host&apos; =&gt; &apos;127.0.0.1&apos;, // 127.0.0.1为本机IP位置 &apos;db&apos; =&gt; &apos;student&apos;, // 要连接到的本地数据库名 &apos;db_user&apos; =&gt; &apos;root&apos;, // 连接的用户名 &apos;db_pwd&apos; =&gt; &apos;123456&apos;, // 连接的密码 ); 二、建立数据库连接 1$mysqli = @new mysqli($mysql_conf[&apos;host&apos;], $mysql_conf[&apos;db_user&apos;], $mysql_conf[&apos;db_pwd&apos;]); 三、连接失败问题的判断处理 &emsp;&emsp;在说到连接问题之前，先介绍两个函数 &emsp;1. $mysqli-&gt;connect_errno()函数，这个是检查PHP是否连接上MYSQL，就是一个判断函数，具体用法如下： 123if ($mysqli-&gt;connect_errno) &#123; die(&quot;could not connect to the database:\\n&quot; . $mysqli-&gt;connect_error); // 诊断连接错误&#125; &emsp;2. $mysqli-&gt;select_db()函数，用于更改连接的默认数据库，语法为mysqli_select_db(connection,dbname); &emsp;这里遇到一个问题，函数mysqli_select_db有两个参数况且都是必须的，这里只用了一个dbname参数就完成了连接，问题先放放，明天解决。连接数据库代码如下： 123456 $mysqli-&gt;query(&quot;set names &apos;utf8&apos;;&quot;);//编码转化 $select_db = $mysqli-&gt;select_db($mysql_conf[&apos;db&apos;]); if (!$select_db) &#123; die(&quot;could not connect to the db:\\n&quot; . $mysqli-&gt;error); // 处理连接失败情况&#125; baoming.php文件的实现&emsp;&emsp;刚才在html文件中是通过http.post发送给了baoming.php报名信息的，这里要在baoming中进行处理信息并放入数据库一、首先引入connect.php，不连接数据库怎么搞都没有意义 1include(&apos;connect.php&apos;); 二、获取报名信息 123$name=$_POST[&apos;name&apos;];$num=$_POST[&apos;num&apos;];$intro=$_POST[&apos;intro&apos;]; 三、向数据库student的naxin表中insert报名信息 12345678910111213141516 // 首先判断name是否为空，从而判断信息有无，一般这里name都是可以获取到的，因为在html文件中已经设置了如果name为空返回重填 if($name)&#123; // 插入语句 $sql=&quot;insert into naxin values (&apos;$name&apos;,&apos;$num&apos;，&apos;$intro&apos;);&quot;; // 执行sql语句，查询sql信息是否存在 $res = $mysqli-&gt;query($sql); if($res)&#123; echo &apos;0&apos;; return; &#125;else&#123; echo &apos;erro&apos;; &#125;&#125;else&#123; echo &apos;erro&apos;;&#125; 综上所述，完成了将网页输入信息存放至本地数据库naxin表中。","categories":[],"tags":[]},{"title":"The difference between Oracle and MySQ","slug":"Oracle和Mysql的区别","date":"2019-09-27T12:26:45.000Z","updated":"2019-09-27T15:37:57.231Z","comments":true,"path":"2019/09/27/Oracle和Mysql的区别/","link":"","permalink":"http://yoursite.com/2019/09/27/Oracle和Mysql的区别/","excerpt":"","text":"2019/9/27——Oracle和MySQL区别1、mysql可以没有from，oracle必须有，可以写成from dual； 2、mysql使用concat()函数连接字符串，oracle不仅有concat()函数，还可以使用||； 3、mysql没有全外连接，使用集合连接代替，oracle有全外连接，而且左右外连接有自己的语法：(+)； 4、mysql分页使用limit，oracle分页得借助rownum关键字； 5、mysql自动增长auto_increment，oracle使用序列代替； 6、mysql直接书写循环判断语句，oracle得借助PLSQL语句； 7、mysql判断使用elseif，oracle使用elsif； 8、mysql可以直接增删改，oracle需要commit； 9、group by，在下oracle下用group by的话，group by后面的字段必须在select后面出现，不然会报错的，而mysql却不会；","categories":[],"tags":[]},{"title":"Database basics part 2","slug":"数据库基础2","date":"2019-09-26T12:26:45.000Z","updated":"2019-09-27T15:36:45.070Z","comments":true,"path":"2019/09/26/数据库基础2/","link":"","permalink":"http://yoursite.com/2019/09/26/数据库基础2/","excerpt":"2019/9/26——The Oracle base一、数据库常用数据类型&emsp;&emsp;上一篇blog简单介绍了Oracle数据库中表的建立，对表信息的增删改。这里归纳一下建表的过程中常用的四个数据类型： &emsp;①char(n)，char类型是长度为n的定长型字符串。由于是定长的字符串，故在插入信息的时候要插入固定为n长度的字符串，否则会导致数据插入不进去。 &emsp;②varchar2(n)，最大长度为n的变长字符串。由于在char中可能会导致浪费现象，varchar2相比于char类型最大的优势就是能节省储存空间。 &emsp;③number(n)，最常用的数字类型。 &emsp;④data，常用的日期类型，格式为YYYY-MM-DD。","text":"2019/9/26——The Oracle base一、数据库常用数据类型&emsp;&emsp;上一篇blog简单介绍了Oracle数据库中表的建立，对表信息的增删改。这里归纳一下建表的过程中常用的四个数据类型： &emsp;①char(n)，char类型是长度为n的定长型字符串。由于是定长的字符串，故在插入信息的时候要插入固定为n长度的字符串，否则会导致数据插入不进去。 &emsp;②varchar2(n)，最大长度为n的变长字符串。由于在char中可能会导致浪费现象，varchar2相比于char类型最大的优势就是能节省储存空间。 &emsp;③number(n)，最常用的数字类型。 &emsp;④data，常用的日期类型，格式为YYYY-MM-DD。 二、修改表的骨架信息&emsp;&emsp;上一篇blog中提到了update和delete的使用，update和delete往往是对表格中的内容进行修改删除。而当user有对表格骨架，例如有增加或删除某一条属性的需求时，就要用到alter命令，具体alter命令的实现如下： 增加一条属性 1alter table Student add S_entrance date; //增加学生入学时间的属性 删除一条属性 1alter table student drop column sid; //删除属性名为sid的属性 修改某一属性的字段名称 1alter table Student rename column sage to sage1; //将sage属性重命名为sage1 修改某一属性的数据类型 1alter table student modify sid varchar2(10); //将sid的数据类型改为varchar2(10) 三、删除表&emsp;&emsp;删除表的操作一定要小心使用，很可能会出现很多连带反应导致其他表或视图也受到影响 12 drop table &lt;表名&gt; [RESTRICT|CASCADE]; //若选择RESTRICT，要删除的表不能被其他标的约束所引用，不能有视图。如果存在依赖对象，则此表不可删除。若选择CASCADE，在删除表格的同时，相关的对象，例如视图会被一起删除。","categories":[],"tags":[]},{"title":"Database basics part 1","slug":"数据库基础1","date":"2019-09-24T12:26:45.000Z","updated":"2019-09-27T15:36:46.984Z","comments":true,"path":"2019/09/24/数据库基础1/","link":"","permalink":"http://yoursite.com/2019/09/24/数据库基础1/","excerpt":"2019/9/24——The Oracle base一、增加user、分配权限1.连接管理员账户 1connect system/&lt;管理员密码&gt;; 2.增加user语句 1create user &lt;用户名&gt; identified by &lt;密码&gt;; 3.赋给user权限 1grant connect,resource to &lt;用户名&gt;; 4.连接用户 1connect &lt;用户名&gt;/&lt;密码&gt;;","text":"2019/9/24——The Oracle base一、增加user、分配权限1.连接管理员账户 1connect system/&lt;管理员密码&gt;; 2.增加user语句 1create user &lt;用户名&gt; identified by &lt;密码&gt;; 3.赋给user权限 1grant connect,resource to &lt;用户名&gt;; 4.连接用户 1connect &lt;用户名&gt;/&lt;密码&gt;; 二、建表1.建立关系表(此处以学生表为例) 1234567create table Student( sid char(4) primary key, //学号设置为主键 sname varchar(10), sdept varchar(10), sage number(2)); 三、对表中数据进行增加、删除、更新1.增加数据 1234insert into Student values(&apos;1001&apos;,&apos;szc&apos;,&apos;SE&apos;,19);insert into Student values(&apos;1002&apos;,&apos;qgl&apos;,&apos;SE&apos;,20);insert into Student values(&apos;1003&apos;,&apos;xjl&apos;,&apos;SE&apos;,19);insert into Student values(&apos;1004&apos;,&apos;lxc&apos;,&apos;SE&apos;,21); 2.修改数据 12345678update &lt;表名&gt;set &lt;列名&gt;=&lt;表达式&gt;[where &lt;条件&gt;]; //此处where语句可用可不用，若不用即对整个表中的信息进行集中操作，同时where进行筛选时，可以是复杂的select嵌套语句//此处简单列举一例，将名为szc的年龄增加一岁。update Studentset sage+1where sname = &apos;szc&apos;; 3.删除数据 12345//此处删除数据是指删除一条信息(一个元组或多个元组的值)，要和删掉表格的行列等区分开，删掉表格的行列等是改变表的格式，要使用alter语句进行操作，后续会提到//此处简单列举一例，删除学号为1001的学生信息delete from Studentwhere sid = &apos;1001&apos;;","categories":[],"tags":[]},{"title":"Update my personal blog topics","slug":"Change my blog theme","date":"2019-09-23T12:26:45.000Z","updated":"2019-09-27T15:36:49.092Z","comments":true,"path":"2019/09/23/Change my blog theme/","link":"","permalink":"http://yoursite.com/2019/09/23/Change my blog theme/","excerpt":"","text":"2019/9/23——更新个人blog主题smackdown主题的切换&emsp;在免费的hexo主题网站上找到了一个基于yilia的hexo主题，个人比较喜欢也推荐大家感受下这个主题，git链接：https://github.com/smackgg/hexo-theme-smackdown.git。&emsp;具体实现切换主题的方法很简单，cmd窗口在当前blog根目录下cd themes文件，执行克隆命令hexo clone + https://github.com/smackgg/hexo-theme-smackdown.git; clone完毕后，返回blog根目录修改根目录下的_config.yml设置中的theme属性，原hexo框架安装后theme属性会自动设置为 landscape ，将theme属性修改为刚刚clone下来的文件名 smackgg 就可以啦。 具体的blog头像等个人设置的修改&emsp;将需要的图片等信息放入克隆下来的smackgg的source文件夹中，进入_config.yml修改即可，注意此时的_config.yml文件是clone下来文件中的_config.yml文件，而不是根目录下的_config.yml文件。例，我将author.jpg放入smackgg下的source中，在_config.yml的头像url中填入/img/author.jpg即可完成修改。","categories":[],"tags":[]},{"title":"My first blog post","slug":"我的第一篇博客文章","date":"2019-09-22T12:26:45.000Z","updated":"2019-09-27T15:35:31.215Z","comments":true,"path":"2019/09/22/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2019/09/22/我的第一篇博客文章/","excerpt":"2019/9/22——Blog安装并部署个人blog&emsp;按照lxc发的视频(视频链接: https://www.bilibili.com/video/av44544186?t=1157)完成了个人blog的搭建。把blog部署到本地后，利用github将本地文件部署到http://shizuocheng.github.io。 新建博客文章一、cmd命令完成新建博客&emsp;①在cmd的blog根目录命令下，cd source/_posts&emsp;②执行hexo new “博客文件名”(生成的文件的后缀默认.md)&emsp;③进入新建的md文件中写博客内容，完毕后退回blog根目录下&emsp;④执行语句hexo g进行提交，执行hexo s进入local:4000下看是否已生成&emsp;⑤确认无误后在blog根目录下执行hexo d命令同步到远端","text":"2019/9/22——Blog安装并部署个人blog&emsp;按照lxc发的视频(视频链接: https://www.bilibili.com/video/av44544186?t=1157)完成了个人blog的搭建。把blog部署到本地后，利用github将本地文件部署到http://shizuocheng.github.io。 新建博客文章一、cmd命令完成新建博客&emsp;①在cmd的blog根目录命令下，cd source/_posts&emsp;②执行hexo new “博客文件名”(生成的文件的后缀默认.md)&emsp;③进入新建的md文件中写博客内容，完毕后退回blog根目录下&emsp;④执行语句hexo g进行提交，执行hexo s进入local:4000下看是否已生成&emsp;⑤确认无误后在blog根目录下执行hexo d命令同步到远端 二、直接在本地修改后上传&emsp;①在本地文件夹中进入blog下的source文件下的_posts文件，进入要修改的md文章文件&emsp;②在cmd命令窗口下，进入blog根目录分别执行hexo clean,hexo g,hexo s,hexo d完成远端部署 修改本地文章并同步到blog网页&emsp;首先进入要修改的md文件下进行修改，完毕后cmd命令中进入blog路径。首先执行hexo clean命令，其次执行hexo g命令完成提交，之后执行hexo s命令，执行hexo s命令后可进入localhost:4000，查看相关文章效果，从而进一步进行对md文档的部署完善。 &emsp;确认无误后，进入blog执行hexo d命令，稍等片刻即可同步到blog网页。&emsp;综上所述，在blog下，修改md文档—&gt;&gt;hexo clean—&gt;&gt;hexo g—&gt;&gt;hexo s—&gt;&gt;hexo d完成同步。","categories":[],"tags":[]}]}